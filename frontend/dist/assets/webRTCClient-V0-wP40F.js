function k({wsUrl:f,token:W}){let d,s,g,R;const b=[{urls:["stun:stun.l.google.com:19302"]}];async function r(S,C,o,i=null){try{const c=W?`${f}${f.includes("?")?"&":"?"}token=${encodeURIComponent(W)}`:f;console.log("[WebRTC] Connecting WebSocket to:",c),d=new WebSocket(c)}catch(c){console.error("[WebRTC] WebSocket connection failed:",c),o&&o("ws-error");return}const l="student_"+Math.random().toString(36).substr(2,9);d.onopen=async()=>{console.log("[WebRTC] WebSocket connected, joining class:",S),d.send(JSON.stringify({type:"join",classId:S,userId:l,role:"student"})),s=new RTCPeerConnection({iceServers:b}),g=new MediaStream,s.ontrack=c=>{console.log("[WebRTC] *** TRACK RECEIVED ***",{kind:c.track.kind,label:c.track.label,enabled:c.track.enabled,readyState:c.track.readyState,id:c.track.id}),g.addTrack(c.track),console.log("[WebRTC] Track added to stream. Total tracks:",g.getTracks().length),console.log("[WebRTC] Stream now has:",{audioTracks:g.getAudioTracks().length,videoTracks:g.getVideoTracks().length}),c.track.kind==="audio"?(console.log("[WebRTC] *** CALLING AUDIO CALLBACK ***"),C&&C(g),g.getVideoTracks().length>0&&(console.log("[WebRTC] Audio received but also have video tracks - calling video callback"),i&&i(g))):c.track.kind==="video"&&(console.log("[WebRTC] *** CALLING VIDEO CALLBACK ***"),console.log("[WebRTC] Video callback function exists:",!!i),i&&i(g),g.getAudioTracks().length>0&&(console.log("[WebRTC] Video received but also have audio tracks - calling audio callback"),C&&C(g)))},s.onicecandidate=c=>{c.candidate&&(console.log("[WebRTC] Sending ICE candidate to teacher"),d.send(JSON.stringify({type:"candidate",candidate:c.candidate,from:l})))},s.onconnectionstatechange=()=>{console.log("[WebRTC] Connection state:",s.connectionState),s.connectionState==="connected"&&clearTimeout(R)},console.log("[WebRTC] Student waiting for teacher stream..."),R=setTimeout(()=>{console.log("[WebRTC] Connection timeout, current state:",s.connectionState),s.connectionState!=="connected"&&o&&o("webrtc-failed")},1e4)},d.onmessage=async c=>{const n=JSON.parse(c.data);if(console.log("[WebRTC] Received message:",n.type,"from:",n.from,"to:",n.to),n.type==="offer"&&n.from&&n.from.startsWith("teacher_")){console.log("[WebRTC] Received offer from teacher:",n.from);try{await s.setRemoteDescription({type:"offer",sdp:n.sdp});const e=await s.createAnswer();await s.setLocalDescription(e),console.log("[WebRTC] Sending answer back to teacher"),d.send(JSON.stringify({type:"answer",sdp:e.sdp,to:n.from,from:l}))}catch(e){console.error("[WebRTC] Error handling offer:",e),o&&o("webrtc-failed")}}else if(n.type==="candidate"&&n.from&&n.from.startsWith("teacher_")){console.log("[WebRTC] Adding ICE candidate from teacher");try{await s.addIceCandidate(n.candidate)}catch(e){console.log("[WebRTC] ICE candidate error:",e)}}else n.type==="event"?o&&o(n.name):n.type==="peer_joined"&&(console.log("[WebRTC] Peer joined:",n.userId,n.role),n.role==="teacher"&&console.log("[WebRTC] Teacher joined - waiting for offer..."))},d.onerror=c=>{console.error("[WebRTC] WebSocket error:",c),o&&o("ws-error")},d.onclose=()=>{console.log("[WebRTC] WebSocket closed"),o&&o("ws-closed")}}function m(){clearTimeout(R),s&&s.close(),d&&d.readyState===WebSocket.OPEN&&d.close()}return{joinClass:r,leave:m}}async function p({wsUrl:f,token:W,classId:d,onEvent:s,includeScreen:g=!1}){console.log("[Faculty WebRTC] Starting faculty broadcast"),console.log("[Faculty WebRTC] Parameters:",{wsUrl:f,token:W,classId:d,includeScreen:g});const R=[{urls:"stun:stun.l.google.com:19302"}],b=new Map;console.log("[Faculty WebRTC] Getting user media...");let r;if(g)try{console.log("[Faculty WebRTC] Requesting screen share...");const o=await navigator.mediaDevices.getDisplayMedia({video:{width:{ideal:1280},height:{ideal:720},frameRate:{ideal:15}},audio:!0});console.log("[Faculty WebRTC] Getting microphone audio...");const i=await navigator.mediaDevices.getUserMedia({audio:{echoCancellation:!0,noiseSuppression:!0,autoGainControl:!0,sampleRate:44100},video:!1});r=new MediaStream,o.getVideoTracks().forEach(l=>r.addTrack(l)),i.getAudioTracks().forEach(l=>r.addTrack(l)),console.log("[Faculty WebRTC] Combined screen + audio stream created")}catch(o){console.log("[Faculty WebRTC] Screen share failed, falling back to audio only:",o.message),r=await navigator.mediaDevices.getUserMedia({audio:{echoCancellation:!0,noiseSuppression:!0,autoGainControl:!0,sampleRate:44100},video:!1})}else r=await navigator.mediaDevices.getUserMedia({audio:{echoCancellation:!0,noiseSuppression:!0,autoGainControl:!0,sampleRate:44100},video:!1});console.log("[Faculty WebRTC] Media stream obtained, tracks:",r.getTracks().length);const m=r.getAudioTracks(),S=r.getVideoTracks();console.log("[Faculty WebRTC] Audio tracks:",m.length),console.log("[Faculty WebRTC] Video tracks:",S.length),console.log("[Faculty WebRTC] ALL TRACKS IN STREAM:"),r.getTracks().forEach((o,i)=>{console.log(`[Faculty WebRTC] Track ${i}:`,{kind:o.kind,enabled:o.enabled,muted:o.muted,readyState:o.readyState,label:o.label,settings:o.getSettings()})}),m.forEach((o,i)=>{console.log(`[Faculty WebRTC] Audio track ${i}:`,{enabled:o.enabled,muted:o.muted,readyState:o.readyState,label:o.label,settings:o.getSettings()}),o.enabled=!0}),S.forEach((o,i)=>{console.log(`[Faculty WebRTC] Video track ${i}:`,{enabled:o.enabled,muted:o.muted,readyState:o.readyState,label:o.label,settings:o.getSettings()})});const C="teacher_"+Math.random().toString(36).substr(2,9);return console.log("[Faculty WebRTC] Teacher ID:",C),new Promise((o,i)=>{console.log("[Faculty WebRTC] Creating WebSocket connection to:",f);let l,c=!1;const n=async e=>{console.log(`[Faculty WebRTC] Creating connection for student: ${e}`);const t=new RTCPeerConnection({iceServers:R});b.set(e,t),console.log(`[Faculty WebRTC] *** ADDING TRACKS TO ${e} ***`);const u=r.getAudioTracks(),T=r.getVideoTracks();console.log(`[Faculty WebRTC] Available audio tracks: ${u.length}`),console.log(`[Faculty WebRTC] Available video tracks: ${T.length}`),r.getTracks().forEach((a,y)=>{console.log(`[Faculty WebRTC] Track ${y} for ${e}:`,{kind:a.kind,label:a.label,enabled:a.enabled,readyState:a.readyState,id:a.id})});for(const a of u){const y=t.addTrack(a,r);console.log(`[Faculty WebRTC] ✅ Added audio track to ${e}:`,{label:a.label,enabled:a.enabled,senderId:y?"OK":"FAILED"})}for(const a of T){const y=t.addTrack(a,r);console.log(`[Faculty WebRTC] ✅ Added video track to ${e}:`,{label:a.label,enabled:a.enabled,senderId:y?"OK":"FAILED"})}console.log(`[Faculty WebRTC] *** TOTAL TRACKS ADDED TO ${e}: ${u.length+T.length} ***`),t.onicecandidate=a=>{a.candidate&&(console.log(`[Faculty WebRTC] Sending ICE candidate to student: ${e}`),l.send(JSON.stringify({type:"candidate",candidate:a.candidate,to:e,from:C})))},t.onconnectionstatechange=()=>{console.log(`[Faculty WebRTC] Connection to ${e}:`,t.connectionState),t.connectionState==="connected"?s&&s(`student-connected:${e}`):(t.connectionState==="disconnected"||t.connectionState==="failed")&&(b.delete(e),s&&s(`student-disconnected:${e}`))};try{console.log(`[Faculty WebRTC] Creating offer for student: ${e}`);const a=await t.createOffer();console.log(`[Faculty WebRTC] *** SDP ANALYSIS FOR ${e} ***`),console.log("[Faculty WebRTC] Offer SDP contains 'video':",a.sdp.includes("video")),console.log("[Faculty WebRTC] Offer SDP contains 'audio':",a.sdp.includes("audio")),console.log("[Faculty WebRTC] Offer SDP video lines:",a.sdp.split(`
`).filter(y=>y.includes("video"))),await t.setLocalDescription(a),console.log(`[Faculty WebRTC] Sending offer to student: ${e}`),l.send(JSON.stringify({type:"offer",sdp:a.sdp,to:e,from:C}))}catch(a){console.error(`[Faculty WebRTC] Error creating offer for ${e}:`,a)}};try{const e=W?`${f}${f.includes("?")?"&":"?"}token=${encodeURIComponent(W)}`:f;console.log("[Faculty WebRTC] Connecting WebSocket to:",e),l=new WebSocket(e),console.log("[Faculty WebRTC] WebSocket object created")}catch(e){console.error("[Faculty WebRTC] Failed to create WebSocket:",e),i(new Error("Failed to create WebSocket: "+e.message));return}l.onerror=e=>{console.error("[Faculty WebRTC] WebSocket error event:",e),console.error("[Faculty WebRTC] WebSocket readyState:",l.readyState),c||i(new Error("WebSocket connection failed: "+e.message))},l.onclose=e=>{console.log("[Faculty WebRTC] WebSocket close event:",{code:e.code,reason:e.reason,wasClean:e.wasClean}),c||i(new Error(`WebSocket closed before connection established: ${e.code} - ${e.reason}`))},l.onopen=async()=>{console.log("[Faculty WebRTC] WebSocket onopen event triggered"),console.log("[Faculty WebRTC] WebSocket readyState:",l.readyState),c=!0;const e={type:"join",classId:d||"default",userId:C,role:"teacher"};console.log("[Faculty WebRTC] Sending join message:",e);try{l.send(JSON.stringify(e)),console.log("[Faculty WebRTC] Join message sent successfully")}catch(t){console.error("[Faculty WebRTC] Error sending join message:",t),i(new Error("Failed to send join message: "+t.message));return}o({stop:()=>{console.log("[Faculty WebRTC] Stopping broadcast");for(const[t,u]of b)u.close();b.clear(),r.getTracks().forEach(t=>t.stop()),l.readyState===WebSocket.OPEN&&l.close()},stream:r,getConnectedStudents:()=>b.size,getStudentIds:()=>Array.from(b.keys())})},l.onmessage=async e=>{const t=JSON.parse(e.data);if(console.log("[Faculty WebRTC] Received message:",t.type,"from:",t.from),t.type==="peer_joined"&&t.role==="student")console.log(`[Faculty WebRTC] Student joined: ${t.userId}`),setTimeout(()=>{console.log(`[Faculty WebRTC] Initiating connection to student: ${t.userId}`),n(t.userId)},1e3);else if(t.type==="answer"&&t.from&&t.from.startsWith("student_")){const u=t.from,T=b.get(u);if(T){console.log(`[Faculty WebRTC] Received answer from student: ${u}`);try{await T.setRemoteDescription({type:"answer",sdp:t.sdp})}catch(a){console.error(`[Faculty WebRTC] Error setting remote description for ${u}:`,a)}}}else if(t.type==="candidate"&&t.from&&t.from.startsWith("student_")){const u=t.from,T=b.get(u);if(T){console.log(`[Faculty WebRTC] Adding ICE candidate from student: ${u}`);try{await T.addIceCandidate(t.candidate)}catch(a){console.log(`[Faculty WebRTC] ICE candidate error for ${u}:`,a)}}}}})}export{p as startFacultyBroadcast,k as webRTCClient};
